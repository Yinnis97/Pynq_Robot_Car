
#include "Globals.h"

void	 	IICPs_Setup		(u16 DeviceId);
void 		Print_Values	(void);
void 		Check_Status	(int status,char* status_msg);

S_Sensor_data Speed_Data_1;
S_Sensor_data Speed_Data_2;
MPU_data mpu_data;

int main()
{
	int Status;
	u32 highTime;

    init_platform();

    // Initialize IIC
    IICPs_Setup(IIC_DEVICE_ID);

    // Initialize Timers
	XTmrCtr_Initialize(&TimerCounterInst_1, AXI_TIMER_ID_1);
	XTmrCtr_Initialize(&TimerCounterInst_2, AXI_TIMER_ID_2);
	XTmrCtr_Initialize(&TimerCounterInst_3, AXI_TIMER_ID_3);
	XTmrCtr_Initialize(&TimerCounterInst_4, AXI_TIMER_ID_4);

    // Disable PWM for reconfiguration
    XTmrCtr_PwmDisable(&TimerCounterInst_1);
    XTmrCtr_PwmDisable(&TimerCounterInst_2);
    XTmrCtr_PwmDisable(&TimerCounterInst_3);
    XTmrCtr_PwmDisable(&TimerCounterInst_4);

    // Set hightime
	highTime = PWM_PERIOD / DUTYCYCLE_DIVISOR;

	// Configure PWM
	XTmrCtr_PwmConfigure(&TimerCounterInst_1, PWM_PERIOD, highTime);
	XTmrCtr_PwmConfigure(&TimerCounterInst_2, PWM_PERIOD, highTime);
	XTmrCtr_PwmConfigure(&TimerCounterInst_3, PWM_PERIOD, highTime);
	XTmrCtr_PwmConfigure(&TimerCounterInst_4, PWM_PERIOD, highTime);

	// Enable PWM after reconfiguration
	XTmrCtr_PwmEnable(&TimerCounterInst_1);
	XTmrCtr_PwmEnable(&TimerCounterInst_2);
	XTmrCtr_PwmEnable(&TimerCounterInst_3);
	XTmrCtr_PwmEnable(&TimerCounterInst_4);

	while(1)
	{
		// Write to ACCEL_XOUT_H to start reading.
		Status = XIicPs_MasterSendPolled(&Iic, MPU_read_accx, 1, IIC_SLAVE_ADDR);
		Check_Status(Status,"MasterSendPolled");

		while (XIicPs_BusIsBusy(&Iic));

		// Read MPU data.
		Status = XIicPs_MasterRecvPolled(&Iic, MPU_buffer, 14, IIC_SLAVE_ADDR);
		Check_Status(Status,"MasterRecvPolled");

		// Parse mpu data.
		mpu_data.acc_x = (MPU_buffer[0] << 8) | MPU_buffer[1];
		mpu_data.acc_y = (MPU_buffer[2] << 8) | MPU_buffer[3];
		mpu_data.acc_z = (MPU_buffer[4] << 8) | MPU_buffer[5];

		// Read Speed sensor data.
		Speed_Data_1.distance = SPEEDSENSOR_IP_mReadReg(XPAR_SPEEDSENSOR_IP_0_S00_AXI_BASEADDR,0);
		Speed_Data_2.distance = SPEEDSENSOR_IP_mReadReg(XPAR_SPEEDSENSOR_IP_1_S00_AXI_BASEADDR,0);
		Speed_Data_1.speed = SPEEDSENSOR_IP_mReadReg(XPAR_SPEEDSENSOR_IP_0_S00_AXI_BASEADDR,4);
		Speed_Data_2.speed = SPEEDSENSOR_IP_mReadReg(XPAR_SPEEDSENSOR_IP_1_S00_AXI_BASEADDR,4);

		sleep(1);
	}


	for(;;);
}

int IICPs_Setup(u16 DeviceId)
{
	int Status;
	XIicPs_Config *Config;

	Config = XIicPs_LookupConfig(DeviceId);
	if (NULL == Config)
	{
		return XST_FAILURE;
	}

	Status = XIicPs_CfgInitialize(&Iic, Config, Config->BaseAddress);
	XIicPs_SetSClk(&Iic, IIC_SCLK_RATE);
	Status = XIicPs_MasterSendPolled(&Iic, MPU_wake_up_data, 2, IIC_SLAVE_ADDR);
	while (XIicPs_BusIsBusy(&Iic));
	usleep(1000);
}

void Print_Values(void)
{
	printf("Acc X = %d\n\r", mpu_data.acc_x);
	printf("Acc Y = %d\n\r", mpu_data.acc_y);
	printf("Acc Z = %d\n\r", mpu_data.acc_z);

	printf("Distance Sensor 1: %ld\n\r", Speed_Data_1.distance);
	printf("Distance Sensor 2: %ld\n\r", Speed_Data_2.distance);
	printf("Speed Sensor 1: %ld\n\r", Speed_Data_1.speed);
	printf("Speed Sensor 2: %ld\n\r", Speed_Data_2.speed);
}

void Check_Status(int status, char* status_msg)
{
	if (Status != XST_SUCCESS)
	{
	    xil_printf("Status Check Failed!\n\r");
	    xil_printf("Error at %c\n\r",status_msg);
	    xil_printf("Status : %d \n\r",Status);
	}
}
